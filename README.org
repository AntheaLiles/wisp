#+bibliography: bibliography.bib

* Wisp

**Wisp** is a Lisp system for [[https://webassembly.org][WebAssembly]] and native
execution.  It aims to offer an unusually pleasant developer
experience both while hacking and in production, though it's
still /very immature/ and far from ready for any serious use.

You can try Wisp running entirely in your browser at
[[https://wisp.node.town][wisp.node.town]].

The Wisp runtime is implemented in [[https://ziglang.org][Zig]].

Wisp has:

  - a browser-based IDE for live hacking and interactive
    debugging;

  - saving and loading of full system state images, including
    debugger state, also in browser local storage;

  - thoughtful integration with the browser environment, Node,
    Deno, and Unix in general;

  - first-class delimited continuations for advanced control
    flow;

  - interactive restartable conditions in the style of Common
    Lisp;

  - first-class stepwise execution for custom debuggers,
    schedulers, etc;

  - sandboxed execution with fine-grained capabilities via
    WebAssembly;

  - and more!

You can join the [[https://discord.gg/BeKtM3x687][Wisp Discord chat]].

The rest of this document is currently a bit rambling.

** WebAssembly as a platform

I've been dreaming of an interactive computing platform that's
social and "portable" so you can migrate even running programs
between browsers, laptops, cloud platforms, etc.

Then I started paying attention to WebAssembly.  It's strongly
supported by all the major browsers.  It runs in Node, native
runtimes like Wasmer and Wasmtime, embedded as a library, on
cloud edge computing platforms, in Kubernetes, and so on.

So it's not just a thing for making 3D games.  It's not Java,
it's not a whole platform bundle.  I had a hunch that it would
be cool to have a persistent Lisp environment made for this
WebAssembly platform.

The browsers let you have several parallel WebAssembly
threads, aka web workers, with shared memory buffers and
atomic operations, so we can implement real threads.
[[https://emscripten.org/docs/porting/pthreads.html][Emscripten supports pthreads.]]

** Lisp traditions, continuations, etc

I always wanted my computer to be something more like a "Lisp
Machine."  Emacs gives me some of that, but it's not optimal
even as just a Lisp interpreter.  It definitely doesn't
support delimited continuations; it only got lexical scoping
recently.  Although it's relatively advanced in terms of
bytecode and JIT compilation.  Concurrency is kind of a joke.
So there's Common Lisp and McCLIM and stuff, which is
beautiful and amazing.

It's kind of underrated still how Common Lisp is stable since
its ANSI standardization in 1994 but still has deep qualities
that are lacking in contemporary systems.  It's really quite a
competent design; well, it's a merger of several live Lisp
traditions going back to the 1950s.  The object system itself
is a minor miracle.  The full compiler is always available at
runtime for dynamic compilation.  The conditional restart
system makes almost all errors recoverable either
automatically or by manual intervention.  The whole state of
the system can be saved as core snapshots that
reload instantly.

I've become a bit confused about Lisp language traditions and
what I want Wisp to be like.

The Common Lisp tradition is my favorite because of the way it
resembles a virtual machine environment, I guess?
The conditional restart system is a great example: when an
error occurs in a real system, there's often something you can
do to solve it on the spot instead of just crashing.
That's how I want computers to work in general, and it's
definitely something I want in Wisp.

But I don't really want to be limited by the ANSI Common Lisp
standard.  In particular, I want first-class composable
continuations.  Why?  Well, it just makes sense to be able to
do various things with continuations, especially for
implementing concurrency and backtracking and stuff like that.
That's why there are Common Lisp packages for transforming
code into continuation-passing style.  Even Ruby has callcc.
It's like a low-hanging fruit of language design.

** Garbage Collection

Wisp has a simple stop-and-copy garbage collector following
the algorithm published by Cheney in 1970 [cite:@cheney1970].

To summarize the algorithm, we divide the heap in two halves
or "semispaces" which we call the new heap and the old heap,
and to collect garbage we copy all reachable objects into the
new heap and update all relevant pointers with an iterative
breadth-first traversal.

This traversal is very simple and doesn't use any recursive
functions.  We first copy the objects pointed to by roots like
current scope and continuation into the new heap just by
copying their memory with no inspection other than needed to
determine each object's byte size.  We've now filled up a
small prefix of the new heap with copied structures that still
refer to objects in the old heap.  Now we /scavenge/,
iterating from the start of the new heap through every slot of
an instance, every list element, etc, and copy those objects
in the same way as we did the roots.  As we scavenge we move
the /scan/ pointer so that the next round of scavenging begins
where we left off.  For each object we copy into the new heap,
we update its old heap location to replace the object's first
word with the pointer to its new location.  Before copying an
object we check for such a /forwarding pointer/ or /broken
heart/ so we don't copy the same object twice.

Some objects are so foundational that it makes no sense to
allocate them in a garbage-collected heap.  NIL, especially,
should not be moved around.  We do this by just reserving a
small amount of space at the beginning of both semispaces.

* Local Variables :noexport:
  Local Variables:
  fill-column: 62
  End:
