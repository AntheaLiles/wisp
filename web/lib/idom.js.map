{
  "version": 3,
  "sources": ["../node_modules/incremental-dom/dist/incremental-dom-cjs.js", "idom.ts"],
  "sourcesContent": ["\n/**\n * @preserve\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0.\n */\n\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n/**\n * Copyright 2018 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Copyright 2018 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * The name of the HTML attribute that holds the element key\n * (e.g. `<div key=\"foo\">`). The attribute value, if it exists, is then used\n * as the default key when importing an element.\n * If null, no attribute value is used as the default key.\n */\nlet keyAttributeName = \"key\";\nfunction getKeyAttributeName() {\n    return keyAttributeName;\n}\nfunction setKeyAttributeName(name) {\n    keyAttributeName = name;\n}\n\n/**\n * Copyright 2018 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Keeps track whether or not we are in an attributes declaration (after\n * elementOpenStart, but before elementOpenEnd).\n */\nlet inAttributes = false;\n/**\n * Keeps track whether or not we are in an element that should not have its\n * children cleared.\n */\nlet inSkip = false;\n/**\n * Keeps track of whether or not we are in a patch.\n */\nlet inPatch = false;\n/**\n * Asserts that a value exists and is not null or undefined. goog.asserts\n * is not used in order to avoid dependencies on external code.\n * @param val The value to assert is truthy.\n * @returns The value.\n */\nfunction assert(val) {\n    if (!val) {\n        throw new Error(\"Expected value to be defined\");\n    }\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return val;\n}\n/**\n * Makes sure that there is a current patch context.\n * @param functionName The name of the caller, for the error message.\n */\nfunction assertInPatch(functionName) {\n    if (!inPatch) {\n        throw new Error(\"Cannot call \" + functionName + \"() unless in patch.\");\n    }\n}\n/**\n * Makes sure that a patch closes every node that it opened.\n * @param openElement\n * @param root\n */\nfunction assertNoUnclosedTags(openElement, root) {\n    if (openElement === root) {\n        return;\n    }\n    let currentElement = openElement;\n    const openTags = [];\n    while (currentElement && currentElement !== root) {\n        openTags.push(currentElement.nodeName.toLowerCase());\n        currentElement = currentElement.parentNode;\n    }\n    throw new Error(\"One or more tags were not closed:\\n\" + openTags.join(\"\\n\"));\n}\n/**\n * Makes sure that node being outer patched has a parent node.\n * @param parent\n */\nfunction assertPatchOuterHasParentNode(parent) {\n    if (!parent) {\n        console.warn(\"patchOuter requires the node have a parent if there is a key.\");\n    }\n}\n/**\n * Makes sure that the caller is not where attributes are expected.\n * @param functionName The name of the caller, for the error message.\n */\nfunction assertNotInAttributes(functionName) {\n    if (inAttributes) {\n        throw new Error(functionName +\n            \"() can not be called between \" +\n            \"elementOpenStart() and elementOpenEnd().\");\n    }\n}\n/**\n * Makes sure that the caller is not inside an element that has declared skip.\n * @param functionName The name of the caller, for the error message.\n */\nfunction assertNotInSkip(functionName) {\n    if (inSkip) {\n        throw new Error(functionName +\n            \"() may not be called inside an element \" +\n            \"that has called skip().\");\n    }\n}\n/**\n * Makes sure that the caller is where attributes are expected.\n * @param functionName The name of the caller, for the error message.\n */\nfunction assertInAttributes(functionName) {\n    if (!inAttributes) {\n        throw new Error(functionName +\n            \"() can only be called after calling \" +\n            \"elementOpenStart().\");\n    }\n}\n/**\n * Makes sure the patch closes virtual attributes call\n */\nfunction assertVirtualAttributesClosed() {\n    if (inAttributes) {\n        throw new Error(\"elementOpenEnd() must be called after calling \" + \"elementOpenStart().\");\n    }\n}\n/**\n * Makes sure that tags are correctly nested.\n * @param currentNameOrCtor\n * @param nameOrCtor\n */\nfunction assertCloseMatchesOpenTag(currentNameOrCtor, nameOrCtor) {\n    if (currentNameOrCtor !== nameOrCtor) {\n        throw new Error('Received a call to close \"' +\n            nameOrCtor +\n            '\" but \"' +\n            currentNameOrCtor +\n            '\" was open.');\n    }\n}\n/**\n * Makes sure that no children elements have been declared yet in the current\n * element.\n * @param functionName The name of the caller, for the error message.\n * @param previousNode\n */\nfunction assertNoChildrenDeclaredYet(functionName, previousNode) {\n    if (previousNode !== null) {\n        throw new Error(functionName +\n            \"() must come before any child \" +\n            \"declarations inside the current element.\");\n    }\n}\n/**\n * Checks that a call to patchOuter actually patched the element.\n * @param maybeStartNode The value for the currentNode when the patch\n *     started.\n * @param maybeCurrentNode The currentNode when the patch finished.\n * @param expectedNextNode The Node that is expected to follow the\n *    currentNode after the patch;\n * @param expectedPrevNode The Node that is expected to preceed the\n *    currentNode after the patch.\n */\nfunction assertPatchElementNoExtras(maybeStartNode, maybeCurrentNode, expectedNextNode, expectedPrevNode) {\n    const startNode = assert(maybeStartNode);\n    const currentNode = assert(maybeCurrentNode);\n    const wasUpdated = currentNode.nextSibling === expectedNextNode &&\n        currentNode.previousSibling === expectedPrevNode;\n    const wasChanged = currentNode.nextSibling === startNode.nextSibling &&\n        currentNode.previousSibling === expectedPrevNode;\n    const wasRemoved = currentNode === startNode;\n    if (!wasUpdated && !wasChanged && !wasRemoved) {\n        throw new Error(\"There must be exactly one top level call corresponding \" +\n            \"to the patched element.\");\n    }\n}\n/**\n * @param newContext The current patch context.\n */\nfunction updatePatchContext(newContext) {\n    inPatch = newContext != null;\n}\n/**\n * Updates the state of being in an attribute declaration.\n * @param value Whether or not the patch is in an attribute declaration.\n * @return the previous value.\n */\nfunction setInAttributes(value) {\n    const previous = inAttributes;\n    inAttributes = value;\n    return previous;\n}\n/**\n * Updates the state of being in a skip element.\n * @param value Whether or not the patch is skipping the children of a\n *    parent node.\n * @return the previous value.\n */\nfunction setInSkip(value) {\n    const previous = inSkip;\n    inSkip = value;\n    return previous;\n}\n\n/**\n * Copyright 2018 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A cached reference to the hasOwnProperty function.\n */\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n/**\n * A constructor function that will create blank objects.\n */\nfunction Blank() { }\nBlank.prototype = Object.create(null);\n/**\n * Used to prevent property collisions between our \"map\" and its prototype.\n * @param map The map to check.\n * @param property The property to check.\n * @return Whether map has property.\n */\nfunction has(map, property) {\n    return hasOwnProperty.call(map, property);\n}\n/**\n * Creates an map object without a prototype.\n * @returns An Object that can be used as a map.\n */\nfunction createMap() {\n    return new Blank();\n}\n/**\n * Truncates an array, removing items up until length.\n * @param arr The array to truncate.\n * @param length The new length of the array.\n */\nfunction truncateArray(arr, length) {\n    while (arr.length > length) {\n        arr.pop();\n    }\n}\n/**\n * Creates an array for a desired initial size. Note that the array will still\n * be empty.\n * @param initialAllocationSize The initial size to allocate.\n * @returns An empty array, with an initial allocation for the desired size.\n */\nfunction createArray(initialAllocationSize) {\n    const arr = new Array(initialAllocationSize);\n    truncateArray(arr, 0);\n    return arr;\n}\n\n/**\n * Copyright 2018 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst symbols = {\n    default: \"__default\"\n};\n\n/**\n * Copyright 2018 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @param name The name of the attribute. For example \"tabindex\" or\n *    \"xlink:href\".\n * @returns The namespace to use for the attribute, or null if there is\n * no namespace.\n */\nfunction getNamespace(name) {\n    if (name.lastIndexOf(\"xml:\", 0) === 0) {\n        return \"http://www.w3.org/XML/1998/namespace\";\n    }\n    if (name.lastIndexOf(\"xlink:\", 0) === 0) {\n        return \"http://www.w3.org/1999/xlink\";\n    }\n    return null;\n}\n/**\n * Applies an attribute or property to a given Element. If the value is null\n * or undefined, it is removed from the Element. Otherwise, the value is set\n * as an attribute.\n * @param el The element to apply the attribute to.\n * @param name The attribute's name.\n * @param value The attribute's value.\n */\nfunction applyAttr(el, name, value) {\n    if (value == null) {\n        el.removeAttribute(name);\n    }\n    else {\n        const attrNS = getNamespace(name);\n        if (attrNS) {\n            el.setAttributeNS(attrNS, name, String(value));\n        }\n        else {\n            el.setAttribute(name, String(value));\n        }\n    }\n}\n/**\n * Applies a property to a given Element.\n * @param el The element to apply the property to.\n * @param name The property's name.\n * @param value The property's value.\n */\nfunction applyProp(el, name, value) {\n    el[name] = value;\n}\n/**\n * Applies a value to a style declaration. Supports CSS custom properties by\n * setting properties containing a dash using CSSStyleDeclaration.setProperty.\n * @param style A style declaration.\n * @param prop The property to apply. This can be either camelcase or dash\n *    separated. For example: \"backgroundColor\" and \"background-color\" are both\n *    supported.\n * @param value The value of the property.\n */\nfunction setStyleValue(style, prop, value) {\n    if (prop.indexOf(\"-\") >= 0) {\n        style.setProperty(prop, value);\n    }\n    else {\n        style[prop] = value;\n    }\n}\n/**\n * Applies a style to an Element. No vendor prefix expansion is done for\n * property names/values.\n * @param el The Element to apply the style for.\n * @param name The attribute's name.\n * @param  style The style to set. Either a string of css or an object\n *     containing property-value pairs.\n */\nfunction applyStyle(el, name, style) {\n    // MathML elements inherit from Element, which does not have style. We cannot\n    // do `instanceof HTMLElement` / `instanceof SVGElement`, since el can belong\n    // to a different document, so just check that it has a style.\n    assert(\"style\" in el);\n    const elStyle = el.style;\n    if (typeof style === \"string\") {\n        elStyle.cssText = style;\n    }\n    else {\n        elStyle.cssText = \"\";\n        for (const prop in style) {\n            if (has(style, prop)) {\n                setStyleValue(elStyle, prop, style[prop]);\n            }\n        }\n    }\n}\n/**\n * Updates a single attribute on an Element.\n * @param el The Element to apply the attribute to.\n * @param name The attribute's name.\n * @param value The attribute's value. If the value is an object or\n *     function it is set on the Element, otherwise, it is set as an HTML\n *     attribute.\n */\nfunction applyAttributeTyped(el, name, value) {\n    const type = typeof value;\n    if (type === \"object\" || type === \"function\") {\n        applyProp(el, name, value);\n    }\n    else {\n        applyAttr(el, name, value);\n    }\n}\n/**\n * A publicly mutable object to provide custom mutators for attributes.\n * NB: The result of createMap() has to be recast since closure compiler\n * will just assume attributes is \"any\" otherwise and throws away\n * the type annotation set by tsickle.\n */\nconst attributes = createMap();\n// Special generic mutator that's called for any attribute that does not\n// have a specific mutator.\nattributes[symbols.default] = applyAttributeTyped;\nattributes[\"style\"] = applyStyle;\n/**\n * Calls the appropriate attribute mutator for this attribute.\n * @param el The Element to apply the attribute to.\n * @param name The attribute's name.\n * @param value The attribute's value. If the value is an object or\n *     function it is set on the Element, otherwise, it is set as an HTML\n *     attribute.\n */\nfunction updateAttribute(el, name, value) {\n    const mutator = attributes[name] || attributes[symbols.default];\n    mutator(el, name, value);\n}\n\n/**\n * Copyright 2018 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst notifications = {\n    nodesCreated: null,\n    nodesDeleted: null\n};\n\n/**\n * Copyright 2018 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A context object keeps track of the state of a patch.\n */\nclass Context {\n    constructor() {\n        this.created = [];\n        this.deleted = [];\n    }\n    markCreated(node) {\n        this.created.push(node);\n    }\n    markDeleted(node) {\n        this.deleted.push(node);\n    }\n    /**\n     * Notifies about nodes that were created during the patch operation.\n     */\n    notifyChanges() {\n        if (notifications.nodesCreated && this.created.length > 0) {\n            notifications.nodesCreated(this.created);\n        }\n        if (notifications.nodesDeleted && this.deleted.length > 0) {\n            notifications.nodesDeleted(this.deleted);\n        }\n    }\n}\n\n/**\n * Copyright 2018 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Checks if the node is the root of a document. This is either a Document\n * or ShadowRoot. DocumentFragments are included for simplicity of the\n * implementation, though we only want to consider Documents or ShadowRoots.\n * @param node The node to check.\n * @return True if the node the root of a document, false otherwise.\n */\nfunction isDocumentRoot(node) {\n    return node.nodeType === 11 || node.nodeType === 9;\n}\n/**\n * Checks if the node is an Element. This is faster than an instanceof check.\n * @param node The node to check.\n * @return Whether or not the node is an Element.\n */\nfunction isElement(node) {\n    return node.nodeType === 1;\n}\n/**\n * @param  node The node to start at, inclusive.\n * @param  root The root ancestor to get until, exclusive.\n * @return The ancestry of DOM nodes.\n */\nfunction getAncestry(node, root) {\n    const ancestry = [];\n    let cur = node;\n    while (cur !== root) {\n        const n = assert(cur);\n        ancestry.push(n);\n        cur = n.parentNode;\n    }\n    return ancestry;\n}\n/**\n * @param this\n * @returns The root node of the DOM tree that contains this node.\n */\nconst getRootNode = (typeof Node !== \"undefined\" && Node.prototype.getRootNode) ||\n    function () {\n        let cur = this;\n        let prev = cur;\n        while (cur) {\n            prev = cur;\n            cur = cur.parentNode;\n        }\n        return prev;\n    };\n/**\n * @param node The node to get the activeElement for.\n * @returns The activeElement in the Document or ShadowRoot\n *     corresponding to node, if present.\n */\nfunction getActiveElement(node) {\n    const root = getRootNode.call(node);\n    return isDocumentRoot(root) ? root.activeElement : null;\n}\n/**\n * Gets the path of nodes that contain the focused node in the same document as\n * a reference node, up until the root.\n * @param node The reference node to get the activeElement for.\n * @param root The root to get the focused path until.\n * @returns The path of focused parents, if any exist.\n */\nfunction getFocusedPath(node, root) {\n    const activeElement = getActiveElement(node);\n    if (!activeElement || !node.contains(activeElement)) {\n        return [];\n    }\n    return getAncestry(activeElement, root);\n}\n/**\n * Like insertBefore, but instead instead of moving the desired node, instead\n * moves all the other nodes after.\n * @param parentNode\n * @param node\n * @param referenceNode\n */\nfunction moveBefore(parentNode, node, referenceNode) {\n    const insertReferenceNode = node.nextSibling;\n    let cur = referenceNode;\n    while (cur !== null && cur !== node) {\n        const next = cur.nextSibling;\n        parentNode.insertBefore(cur, insertReferenceNode);\n        cur = next;\n    }\n}\n\n/**\n * Copyright 2018 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Keeps track of information needed to perform diffs for a given DOM node.\n */\nclass NodeData {\n    constructor(nameOrCtor, key, text) {\n        /**\n         * An array of attribute name/value pairs, used for quickly diffing the\n         * incomming attributes to see if the DOM node's attributes need to be\n         * updated.\n         */\n        this._attrsArr = null;\n        /**\n         * Whether or not the statics have been applied for the node yet.\n         */\n        this.staticsApplied = false;\n        this.nameOrCtor = nameOrCtor;\n        this.key = key;\n        this.text = text;\n    }\n    hasEmptyAttrsArr() {\n        const attrs = this._attrsArr;\n        return !attrs || !attrs.length;\n    }\n    getAttrsArr(length) {\n        return this._attrsArr || (this._attrsArr = createArray(length));\n    }\n}\n/**\n * Initializes a NodeData object for a Node.\n * @param node The Node to initialized data for.\n * @param nameOrCtor The NameOrCtorDef to use when diffing.\n * @param key The Key for the Node.\n * @param text The data of a Text node, if importing a Text node.\n * @returns A NodeData object with the existing attributes initialized.\n */\nfunction initData(node, nameOrCtor, key, text) {\n    const data = new NodeData(nameOrCtor, key, text);\n    node[\"__incrementalDOMData\"] = data;\n    return data;\n}\n/**\n * @param node The node to check.\n * @returns True if the NodeData already exists, false otherwise.\n */\nfunction isDataInitialized(node) {\n    return Boolean(node[\"__incrementalDOMData\"]);\n}\n/**\n * Records the element's attributes.\n * @param node The Element that may have attributes\n * @param data The Element's data\n */\nfunction recordAttributes(node, data) {\n    const attributes = node.attributes;\n    const length = attributes.length;\n    if (!length) {\n        return;\n    }\n    const attrsArr = data.getAttrsArr(length);\n    // Use a cached length. The attributes array is really a live NamedNodeMap,\n    // which exists as a DOM \"Host Object\" (probably as C++ code). This makes the\n    // usual constant length iteration very difficult to optimize in JITs.\n    for (let i = 0, j = 0; i < length; i += 1, j += 2) {\n        const attr = attributes[i];\n        const name = attr.name;\n        const value = attr.value;\n        attrsArr[j] = name;\n        attrsArr[j + 1] = value;\n    }\n}\n/**\n * Imports single node and its subtree, initializing caches, if it has not\n * already been imported.\n * @param node The node to import.\n * @param fallbackKey A key to use if importing and no key was specified.\n *    Useful when not transmitting keys from serverside render and doing an\n *    immediate no-op diff.\n * @returns The NodeData for the node.\n */\nfunction importSingleNode(node, fallbackKey) {\n    if (node[\"__incrementalDOMData\"]) {\n        return node[\"__incrementalDOMData\"];\n    }\n    const nodeName = isElement(node) ? node.localName : node.nodeName;\n    const keyAttrName = getKeyAttributeName();\n    const keyAttr = isElement(node) && keyAttrName != null\n        ? node.getAttribute(keyAttrName)\n        : null;\n    const key = isElement(node) ? keyAttr || fallbackKey : null;\n    const data = initData(node, nodeName, key);\n    if (isElement(node)) {\n        recordAttributes(node, data);\n    }\n    return data;\n}\n/**\n * Imports node and its subtree, initializing caches.\n * @param node The Node to import.\n */\nfunction importNode(node) {\n    importSingleNode(node);\n    for (let child = node.firstChild; child; child = child.nextSibling) {\n        importNode(child);\n    }\n}\n/**\n * Retrieves the NodeData object for a Node, creating it if necessary.\n * @param node The node to get data for.\n * @param fallbackKey A key to use if importing and no key was specified.\n *    Useful when not transmitting keys from serverside render and doing an\n *    immediate no-op diff.\n * @returns The NodeData for the node.\n */\nfunction getData(node, fallbackKey) {\n    return importSingleNode(node, fallbackKey);\n}\n/**\n * Gets the key for a Node. note that the Node should have been imported\n * by now.\n * @param node The node to check.\n * @returns The key used to create the node.\n */\nfunction getKey(node) {\n    assert(node[\"__incrementalDOMData\"]);\n    return getData(node).key;\n}\n/**\n * Clears all caches from a node and all of its children.\n * @param node The Node to clear the cache for.\n */\nfunction clearCache(node) {\n    node[\"__incrementalDOMData\"] = null;\n    for (let child = node.firstChild; child; child = child.nextSibling) {\n        clearCache(child);\n    }\n}\n\n/**\n * Copyright 2018 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Gets the namespace to create an element (of a given tag) in.\n * @param tag The tag to get the namespace for.\n * @param parent The current parent Node, if any.\n * @returns The namespace to use,\n */\nfunction getNamespaceForTag(tag, parent) {\n    if (tag === \"svg\") {\n        return \"http://www.w3.org/2000/svg\";\n    }\n    if (tag === \"math\") {\n        return \"http://www.w3.org/1998/Math/MathML\";\n    }\n    if (parent == null) {\n        return null;\n    }\n    if (getData(parent).nameOrCtor === \"foreignObject\") {\n        return null;\n    }\n    return parent.namespaceURI;\n}\n/**\n * Creates an Element and initializes the NodeData.\n * @param doc The document with which to create the Element.\n * @param parent The parent of new Element.\n * @param nameOrCtor The tag or constructor for the Element.\n * @param key A key to identify the Element.\n * @returns The newly created Element.\n */\nfunction createElement(doc, parent, nameOrCtor, key) {\n    let el;\n    if (typeof nameOrCtor === \"function\") {\n        el = new nameOrCtor();\n    }\n    else {\n        const namespace = getNamespaceForTag(nameOrCtor, parent);\n        if (namespace) {\n            el = doc.createElementNS(namespace, nameOrCtor);\n        }\n        else {\n            el = doc.createElement(nameOrCtor);\n        }\n    }\n    initData(el, nameOrCtor, key);\n    return el;\n}\n/**\n * Creates a Text Node.\n * @param doc The document with which to create the Element.\n * @returns The newly created Text.\n */\nfunction createText(doc) {\n    const node = doc.createTextNode(\"\");\n    initData(node, \"#text\", null);\n    return node;\n}\n\n/**\n * Copyright 2018 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * The default match function to use, if one was not specified when creating\n * the patcher.\n * @param matchNode The node to match against, unused.\n * @param nameOrCtor The name or constructor as declared.\n * @param expectedNameOrCtor The name or constructor of the existing node.\n * @param key The key as declared.\n * @param expectedKey The key of the existing node.\n * @returns True if the node matches, false otherwise.\n */\nfunction defaultMatchFn(matchNode, nameOrCtor, expectedNameOrCtor, key, expectedKey) {\n    // Key check is done using double equals as we want to treat a null key the\n    // same as undefined. This should be okay as the only values allowed are\n    // strings, null and undefined so the == semantics are not too weird.\n    return nameOrCtor == expectedNameOrCtor && key == expectedKey;\n}\nlet context = null;\nlet currentNode = null;\nlet currentParent = null;\nlet doc = null;\nlet focusPath = [];\nlet matchFn = defaultMatchFn;\n/**\n * Used to build up call arguments. Each patch call gets a separate copy, so\n * this works with nested calls to patch.\n */\nlet argsBuilder = [];\n/**\n * Used to build up attrs for the an element.\n */\nlet attrsBuilder = [];\n/**\n * TODO(sparhami) We should just export argsBuilder directly when Closure\n * Compiler supports ES6 directly.\n * @returns The Array used for building arguments.\n */\nfunction getArgsBuilder() {\n    return argsBuilder;\n}\n/**\n * TODO(sparhami) We should just export attrsBuilder directly when Closure\n * Compiler supports ES6 directly.\n * @returns The Array used for building arguments.\n */\nfunction getAttrsBuilder() {\n    return attrsBuilder;\n}\n/**\n * Checks whether or not the current node matches the specified nameOrCtor and\n * key. This uses the specified match function when creating the patcher.\n * @param matchNode A node to match the data to.\n * @param nameOrCtor The name or constructor to check for.\n * @param key The key used to identify the Node.\n * @return True if the node matches, false otherwise.\n */\nfunction matches(matchNode, nameOrCtor, key) {\n    const data = getData(matchNode, key);\n    return matchFn(matchNode, nameOrCtor, data.nameOrCtor, key, data.key);\n}\n/**\n * Finds the matching node, starting at `node` and looking at the subsequent\n * siblings if a key is used.\n * @param matchNode The node to start looking at.\n * @param nameOrCtor The name or constructor for the Node.\n * @param key The key used to identify the Node.\n * @returns The matching Node, if any exists.\n */\nfunction getMatchingNode(matchNode, nameOrCtor, key) {\n    if (!matchNode) {\n        return null;\n    }\n    let cur = matchNode;\n    do {\n        if (matches(cur, nameOrCtor, key)) {\n            return cur;\n        }\n    } while (key && (cur = cur.nextSibling));\n    return null;\n}\n/**\n * Clears out any unvisited Nodes in a given range.\n * @param maybeParentNode\n * @param startNode The node to start clearing from, inclusive.\n * @param endNode The node to clear until, exclusive.\n */\nfunction clearUnvisitedDOM(maybeParentNode, startNode, endNode) {\n    const parentNode = maybeParentNode;\n    let child = startNode;\n    while (child !== endNode) {\n        const next = child.nextSibling;\n        parentNode.removeChild(child);\n        context.markDeleted(child);\n        child = next;\n    }\n}\n/**\n * @return The next Node to be patched.\n */\nfunction getNextNode() {\n    if (currentNode) {\n        return currentNode.nextSibling;\n    }\n    else {\n        return currentParent.firstChild;\n    }\n}\n/**\n * Changes to the first child of the current node.\n */\nfunction enterNode() {\n    currentParent = currentNode;\n    currentNode = null;\n}\n/**\n * Changes to the parent of the current node, removing any unvisited children.\n */\nfunction exitNode() {\n    clearUnvisitedDOM(currentParent, getNextNode(), null);\n    currentNode = currentParent;\n    currentParent = currentParent.parentNode;\n}\n/**\n * Changes to the next sibling of the current node.\n */\nfunction nextNode() {\n    currentNode = getNextNode();\n}\n/**\n * Creates a Node and marking it as created.\n * @param nameOrCtor The name or constructor for the Node.\n * @param key The key used to identify the Node.\n * @return The newly created node.\n */\nfunction createNode(nameOrCtor, key) {\n    let node;\n    if (nameOrCtor === \"#text\") {\n        node = createText(doc);\n    }\n    else {\n        node = createElement(doc, currentParent, nameOrCtor, key);\n    }\n    context.markCreated(node);\n    return node;\n}\n/**\n * Aligns the virtual Node definition with the actual DOM, moving the\n * corresponding DOM node to the correct location or creating it if necessary.\n * @param nameOrCtor The name or constructor for the Node.\n * @param key The key used to identify the Node.\n */\nfunction alignWithDOM(nameOrCtor, key) {\n    nextNode();\n    const existingNode = getMatchingNode(currentNode, nameOrCtor, key);\n    const node = existingNode || createNode(nameOrCtor, key);\n    // If we are at the matching node, then we are done.\n    if (node === currentNode) {\n        return;\n    }\n    // Re-order the node into the right position, preserving focus if either\n    // node or currentNode are focused by making sure that they are not detached\n    // from the DOM.\n    if (focusPath.indexOf(node) >= 0) {\n        // Move everything else before the node.\n        moveBefore(currentParent, node, currentNode);\n    }\n    else {\n        currentParent.insertBefore(node, currentNode);\n    }\n    currentNode = node;\n}\n/**\n * Makes sure that the current node is an Element with a matching nameOrCtor and\n * key.\n *\n * @param nameOrCtor The tag or constructor for the Element.\n * @param key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @return The corresponding Element.\n */\nfunction open(nameOrCtor, key) {\n    alignWithDOM(nameOrCtor, key);\n    enterNode();\n    return currentParent;\n}\n/**\n * Closes the currently open Element, removing any unvisited children if\n * necessary.\n * @returns The Element that was just closed.\n */\nfunction close() {\n    {\n        setInSkip(false);\n    }\n    exitNode();\n    return currentNode;\n}\n/**\n * Makes sure the current node is a Text node and creates a Text node if it is\n * not.\n * @returns The Text node that was aligned or created.\n */\nfunction text() {\n    alignWithDOM(\"#text\", null);\n    return currentNode;\n}\n/**\n * @returns The current Element being patched.\n */\nfunction currentElement() {\n    {\n        assertInPatch(\"currentElement\");\n        assertNotInAttributes(\"currentElement\");\n    }\n    return currentParent;\n}\n/**\n * @return The Node that will be evaluated for the next instruction.\n */\nfunction currentPointer() {\n    {\n        assertInPatch(\"currentPointer\");\n        assertNotInAttributes(\"currentPointer\");\n    }\n    // TODO(tomnguyen): assert that this is not null\n    return getNextNode();\n}\n/**\n * Skips the children in a subtree, allowing an Element to be closed without\n * clearing out the children.\n */\nfunction skip() {\n    {\n        assertNoChildrenDeclaredYet(\"skip\", currentNode);\n        setInSkip(true);\n    }\n    currentNode = currentParent.lastChild;\n}\n/**\n * Returns a patcher function that sets up and restores a patch context,\n * running the run function with the provided data.\n * @param run The function that will run the patch.\n * @param patchConfig The configuration to use for the patch.\n * @returns The created patch function.\n */\nfunction createPatcher(run, patchConfig = {}) {\n    const { matches = defaultMatchFn } = patchConfig;\n    const f = (node, fn, data) => {\n        const prevContext = context;\n        const prevDoc = doc;\n        const prevFocusPath = focusPath;\n        const prevArgsBuilder = argsBuilder;\n        const prevAttrsBuilder = attrsBuilder;\n        const prevCurrentNode = currentNode;\n        const prevCurrentParent = currentParent;\n        const prevMatchFn = matchFn;\n        let previousInAttributes = false;\n        let previousInSkip = false;\n        doc = node.ownerDocument;\n        context = new Context();\n        matchFn = matches;\n        argsBuilder = [];\n        attrsBuilder = [];\n        currentNode = null;\n        currentParent = node.parentNode;\n        focusPath = getFocusedPath(node, currentParent);\n        {\n            previousInAttributes = setInAttributes(false);\n            previousInSkip = setInSkip(false);\n            updatePatchContext(context);\n        }\n        try {\n            const retVal = run(node, fn, data);\n            {\n                assertVirtualAttributesClosed();\n            }\n            return retVal;\n        }\n        finally {\n            context.notifyChanges();\n            doc = prevDoc;\n            context = prevContext;\n            matchFn = prevMatchFn;\n            argsBuilder = prevArgsBuilder;\n            attrsBuilder = prevAttrsBuilder;\n            currentNode = prevCurrentNode;\n            currentParent = prevCurrentParent;\n            focusPath = prevFocusPath;\n            // Needs to be done after assertions because assertions rely on state\n            // from these methods.\n            {\n                setInAttributes(previousInAttributes);\n                setInSkip(previousInSkip);\n                updatePatchContext(context);\n            }\n        }\n    };\n    return f;\n}\n/**\n * Creates a patcher that patches the document starting at node with a\n * provided function. This function may be called during an existing patch operation.\n * @param patchConfig The config to use for the patch.\n * @returns The created function for patching an Element's children.\n */\nfunction createPatchInner(patchConfig) {\n    return createPatcher((node, fn, data) => {\n        currentNode = node;\n        enterNode();\n        fn(data);\n        exitNode();\n        {\n            assertNoUnclosedTags(currentNode, node);\n        }\n        return node;\n    }, patchConfig);\n}\n/**\n * Creates a patcher that patches an Element with the the provided function.\n * Exactly one top level element call should be made corresponding to `node`.\n * @param patchConfig The config to use for the patch.\n * @returns The created function for patching an Element.\n */\nfunction createPatchOuter(patchConfig) {\n    return createPatcher((node, fn, data) => {\n        const startNode = { nextSibling: node };\n        let expectedNextNode = null;\n        let expectedPrevNode = null;\n        {\n            expectedNextNode = node.nextSibling;\n            expectedPrevNode = node.previousSibling;\n        }\n        currentNode = startNode;\n        fn(data);\n        {\n            assertPatchOuterHasParentNode(currentParent);\n            assertPatchElementNoExtras(startNode, currentNode, expectedNextNode, expectedPrevNode);\n        }\n        if (currentParent) {\n            clearUnvisitedDOM(currentParent, getNextNode(), node.nextSibling);\n        }\n        return startNode === currentNode ? null : currentNode;\n    }, patchConfig);\n}\nconst patchInner = createPatchInner();\nconst patchOuter = createPatchOuter();\n\n/**\n * Copyright 2018 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst buffer = [];\nlet bufferStart = 0;\n/**\n * TODO(tomnguyen): This is a bit silly and really needs to be better typed.\n * @param fn A function to call.\n * @param a The first argument to the function.\n * @param b The second argument to the function.\n * @param c The third argument to the function.\n */\nfunction queueChange(fn, a, b, c) {\n    buffer.push(fn);\n    buffer.push(a);\n    buffer.push(b);\n    buffer.push(c);\n}\n/**\n * Flushes the changes buffer, calling the functions for each change.\n */\nfunction flush() {\n    // A change may cause this function to be called re-entrantly. Keep track of\n    // the portion of the buffer we are consuming. Updates the start pointer so\n    // that the next call knows where to start from.\n    const start = bufferStart;\n    const end = buffer.length;\n    bufferStart = end;\n    for (let i = start; i < end; i += 4) {\n        const fn = buffer[i];\n        fn(buffer[i + 1], buffer[i + 2], buffer[i + 3]);\n    }\n    bufferStart = start;\n    truncateArray(buffer, start);\n}\n\n/**\n * Copyright 2018 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Used to keep track of the previous values when a 2-way diff is necessary.\n * This object is cleared out and reused.\n */\nconst prevValuesMap = createMap();\n/**\n * Calculates the diff between previous and next values, calling the update\n * function when an item has changed value. If an item from the previous values\n * is not present in the the next values, the update function is called with a\n * value of `undefined`.\n * @param prev The previous values, alternating name, value pairs.\n * @param next The next values, alternating name, value pairs.\n * @param updateCtx The context for the updateFn.\n * @param updateFn A function to call when a value has changed.\n */\nfunction calculateDiff(prev, next, updateCtx, updateFn) {\n    const isNew = !prev.length;\n    let i = 0;\n    for (; i < next.length; i += 2) {\n        const name = next[i];\n        if (isNew) {\n            prev[i] = name;\n        }\n        else if (prev[i] !== name) {\n            break;\n        }\n        const value = next[i + 1];\n        if (isNew || prev[i + 1] !== value) {\n            prev[i + 1] = value;\n            queueChange(updateFn, updateCtx, name, value);\n        }\n    }\n    // Items did not line up exactly as before, need to make sure old items are\n    // removed. This should be a rare case.\n    if (i < next.length || i < prev.length) {\n        const startIndex = i;\n        for (i = startIndex; i < prev.length; i += 2) {\n            prevValuesMap[prev[i]] = prev[i + 1];\n        }\n        for (i = startIndex; i < next.length; i += 2) {\n            const name = next[i];\n            const value = next[i + 1];\n            if (prevValuesMap[name] !== value) {\n                queueChange(updateFn, updateCtx, name, value);\n            }\n            prev[i] = name;\n            prev[i + 1] = value;\n            delete prevValuesMap[name];\n        }\n        truncateArray(prev, next.length);\n        for (const name in prevValuesMap) {\n            queueChange(updateFn, updateCtx, name, undefined);\n            delete prevValuesMap[name];\n        }\n    }\n    flush();\n}\n\n/**\n * Copyright 2018 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * The offset in the virtual element declaration where the attributes are\n * specified.\n */\nconst ATTRIBUTES_OFFSET = 3;\n/**\n * Used to keep track of the previous values when a 2-way diff is necessary.\n * This object is reused.\n * TODO(sparhamI) Scope this to a patch so you can call patch from an attribute\n * update.\n */\nconst prevAttrsMap = createMap();\n/**\n * @param element The Element to diff the attrs for.\n * @param data The NodeData associated with the Element.\n */\nfunction diffAttrs(element, data) {\n    const attrsBuilder = getAttrsBuilder();\n    const prevAttrsArr = data.getAttrsArr(attrsBuilder.length);\n    calculateDiff(prevAttrsArr, attrsBuilder, element, updateAttribute);\n    truncateArray(attrsBuilder, 0);\n}\n/**\n * Applies the statics. When importing an Element, any existing attributes that\n * match a static are converted into a static attribute.\n * @param node The Element to apply statics for.\n * @param data The NodeData associated with the Element.\n * @param statics The statics array.\n */\nfunction diffStatics(node, data, statics) {\n    if (data.staticsApplied) {\n        return;\n    }\n    data.staticsApplied = true;\n    if (!statics || !statics.length) {\n        return;\n    }\n    if (data.hasEmptyAttrsArr()) {\n        for (let i = 0; i < statics.length; i += 2) {\n            updateAttribute(node, statics[i], statics[i + 1]);\n        }\n        return;\n    }\n    for (let i = 0; i < statics.length; i += 2) {\n        prevAttrsMap[statics[i]] = i + 1;\n    }\n    const attrsArr = data.getAttrsArr(0);\n    let j = 0;\n    for (let i = 0; i < attrsArr.length; i += 2) {\n        const name = attrsArr[i];\n        const value = attrsArr[i + 1];\n        const staticsIndex = prevAttrsMap[name];\n        if (staticsIndex) {\n            // For any attrs that are static and have the same value, make sure we do\n            // not set them again.\n            if (statics[staticsIndex] === value) {\n                delete prevAttrsMap[name];\n            }\n            continue;\n        }\n        // For any attrs that are dynamic, move them up to the right place.\n        attrsArr[j] = name;\n        attrsArr[j + 1] = value;\n        j += 2;\n    }\n    // Anything after `j` was either moved up already or static.\n    truncateArray(attrsArr, j);\n    for (const name in prevAttrsMap) {\n        updateAttribute(node, name, statics[prevAttrsMap[name]]);\n        delete prevAttrsMap[name];\n    }\n}\n/**\n * Declares a virtual Element at the current location in the document. This\n * corresponds to an opening tag and a elementClose tag is required. This is\n * like elementOpen, but the attributes are defined using the attr function\n * rather than being passed as arguments. Must be folllowed by 0 or more calls\n * to attr, then a call to elementOpenEnd.\n * @param nameOrCtor The Element's tag or constructor.\n * @param key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param statics An array of attribute name/value pairs of the static\n *     attributes for the Element. Attributes will only be set once when the\n *     Element is created.\n */\nfunction elementOpenStart(nameOrCtor, key, statics) {\n    const argsBuilder = getArgsBuilder();\n    {\n        assertNotInAttributes(\"elementOpenStart\");\n        setInAttributes(true);\n    }\n    argsBuilder[0] = nameOrCtor;\n    argsBuilder[1] = key;\n    argsBuilder[2] = statics;\n}\n/**\n * Allows you to define a key after an elementOpenStart. This is useful in\n * templates that define key after an element has been opened ie\n * `<div key('foo')></div>`.\n * @param key The key to use for the next call.\n */\nfunction key(key) {\n    const argsBuilder = getArgsBuilder();\n    {\n        assertInAttributes(\"key\");\n        assert(argsBuilder);\n    }\n    argsBuilder[1] = key;\n}\n/**\n * Buffers an attribute, which will get applied during the next call to\n * `elementOpen`, `elementOpenEnd` or `applyAttrs`.\n * @param name The of the attribute to buffer.\n * @param value The value of the attribute to buffer.\n */\nfunction attr(name, value) {\n    const attrsBuilder = getAttrsBuilder();\n    {\n        assertInPatch(\"attr\");\n    }\n    attrsBuilder.push(name);\n    attrsBuilder.push(value);\n}\n/**\n * Closes an open tag started with elementOpenStart.\n * @return The corresponding Element.\n */\nfunction elementOpenEnd() {\n    const argsBuilder = getArgsBuilder();\n    {\n        assertInAttributes(\"elementOpenEnd\");\n        setInAttributes(false);\n    }\n    const node = open(argsBuilder[0], argsBuilder[1]);\n    const data = getData(node);\n    diffStatics(node, data, argsBuilder[2]);\n    diffAttrs(node, data);\n    truncateArray(argsBuilder, 0);\n    return node;\n}\n/**\n * @param  nameOrCtor The Element's tag or constructor.\n * @param  key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param statics An array of attribute name/value pairs of the static\n *     attributes for the Element. Attributes will only be set once when the\n *     Element is created.\n * @param varArgs, Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return The corresponding Element.\n */\nfunction elementOpen(nameOrCtor, key, \n// Ideally we could tag statics and varArgs as an array where every odd\n// element is a string and every even element is any, but this is hard.\nstatics, ...varArgs) {\n    {\n        assertNotInAttributes(\"elementOpen\");\n        assertNotInSkip(\"elementOpen\");\n    }\n    elementOpenStart(nameOrCtor, key, statics);\n    for (let i = ATTRIBUTES_OFFSET; i < arguments.length; i += 2) {\n        attr(arguments[i], arguments[i + 1]);\n    }\n    return elementOpenEnd();\n}\n/**\n * Applies the currently buffered attrs to the currently open element. This\n * clears the buffered attributes.\n */\nfunction applyAttrs() {\n    const node = currentElement();\n    const data = getData(node);\n    diffAttrs(node, data);\n}\n/**\n * Applies the current static attributes to the currently open element. Note:\n * statics should be applied before calling `applyAtrs`.\n * @param statics The statics to apply to the current element.\n */\nfunction applyStatics(statics) {\n    const node = currentElement();\n    const data = getData(node);\n    diffStatics(node, data, statics);\n}\n/**\n * Closes an open virtual Element.\n *\n * @param nameOrCtor The Element's tag or constructor.\n * @return The corresponding Element.\n */\nfunction elementClose(nameOrCtor) {\n    {\n        assertNotInAttributes(\"elementClose\");\n    }\n    const node = close();\n    {\n        assertCloseMatchesOpenTag(getData(node).nameOrCtor, nameOrCtor);\n    }\n    return node;\n}\n/**\n * Declares a virtual Element at the current location in the document that has\n * no children.\n * @param nameOrCtor The Element's tag or constructor.\n * @param key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param statics An array of attribute name/value pairs of the static\n *     attributes for the Element. Attributes will only be set once when the\n *     Element is created.\n * @param varArgs Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return The corresponding Element.\n */\nfunction elementVoid(nameOrCtor, key, \n// Ideally we could tag statics and varArgs as an array where every odd\n// element is a string and every even element is any, but this is hard.\nstatics, ...varArgs) {\n    elementOpen.apply(null, arguments);\n    return elementClose(nameOrCtor);\n}\n/**\n * Declares a virtual Text at this point in the document.\n *\n * @param value The value of the Text.\n * @param varArgs\n *     Functions to format the value which are called only when the value has\n *     changed.\n * @return The corresponding text node.\n */\nfunction text$1(value, ...varArgs) {\n    {\n        assertNotInAttributes(\"text\");\n        assertNotInSkip(\"text\");\n    }\n    const node = text();\n    const data = getData(node);\n    if (data.text !== value) {\n        data.text = value;\n        let formatted = value;\n        for (let i = 1; i < arguments.length; i += 1) {\n            /*\n             * Call the formatter function directly to prevent leaking arguments.\n             * https://github.com/google/incremental-dom/pull/204#issuecomment-178223574\n             */\n            const fn = arguments[i];\n            formatted = fn(formatted);\n        }\n        // Setting node.data resets the cursor in IE/Edge.\n        if (node.data !== formatted) {\n            node.data = formatted;\n        }\n    }\n    return node;\n}\n\n/**\n * Copyright 2018 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexports.applyAttr = applyAttr;\nexports.applyProp = applyProp;\nexports.attributes = attributes;\nexports.alignWithDOM = alignWithDOM;\nexports.close = close;\nexports.createPatchInner = createPatchInner;\nexports.createPatchOuter = createPatchOuter;\nexports.currentElement = currentElement;\nexports.currentPointer = currentPointer;\nexports.open = open;\nexports.patch = patchInner;\nexports.patchInner = patchInner;\nexports.patchOuter = patchOuter;\nexports.skip = skip;\nexports.skipNode = nextNode;\nexports.setKeyAttributeName = setKeyAttributeName;\nexports.clearCache = clearCache;\nexports.getKey = getKey;\nexports.importNode = importNode;\nexports.isDataInitialized = isDataInitialized;\nexports.notifications = notifications;\nexports.symbols = symbols;\nexports.applyAttrs = applyAttrs;\nexports.applyStatics = applyStatics;\nexports.attr = attr;\nexports.elementClose = elementClose;\nexports.elementOpen = elementOpen;\nexports.elementOpenEnd = elementOpenEnd;\nexports.elementOpenStart = elementOpenStart;\nexports.elementVoid = elementVoid;\nexports.key = key;\nexports.text = text$1;\n//# sourceMappingURL=bundle.cjs.js.map\n", "import * as dom from \"incremental-dom\"\n\nexport default dom\n"],
  "mappings": "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",
  "names": []
}
